#include "book_management.h"
#include <stdio.h>
#include<stdlib.h>
#include<string.h>
/*You can extend the structs (Book and BookList) defined in this head file;
  However, you may not change the function prototypes. 
  You are also free to add additional head files and data structures as needed. 
*/
struct Node* createHead()//create headnode for the booklist
{
	struct Node* headNode = (struct Node*)malloc(sizeof(struct Node));//Application memory
	headNode->next = NULL;
	return headNode;//get the headnode
}
struct Node* createNode(Book book)//create new node
{
	struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));//Application memory
	newNode->book = book;
	newNode->next = NULL;   
	return newNode;//get the new node
}

struct Node* list1 = NULL;//Declaration header
//saves the database of books in the specified file
//returns 0 if books were stored correctly, or an error code otherwise
int store_books(struct Node* headNode,FILE* file)
{
	struct Node* pMove = headNode->next;
	while (pMove != NULL)
	{
		fprintf(file, "%d\t%s\t%s\t%d\t%d\n", pMove->book.id, pMove->book.title, pMove->book.authors,pMove->book.year,pMove->book.copies);
		pMove = pMove->next;
	}
	fclose(file);
	return 0;
}

//loads the database of books from the specified file
//the file must have been generated by a previous call to store_books()
//returns 0 if books were loaded correctly, or an error code otherwise
int load_books(FILE* file,struct Node* headNode)
{
    if (file == NULL)
    {
        printf("File opened failed, exit.");
        exit(0);
    }
    Book a;
    char temp[55];
    memset(temp,'\0',50);
    char buf[55];
    int tempId,tempYear,tempCopies;
    while ( (fgets(buf, 50, file)) != NULL) {
        char* title = (char*) malloc(sizeof(char)*50);
        char* authors = (char*) malloc(sizeof(char)*50);
        sscanf(buf, "%d %s %s %d %d", &tempId, title, authors, &tempYear, &tempCopies);//split string
       a.id=tempId;
       a.title=title;
       a.authors=authors;
       a.year=tempYear;
       a.copies=tempCopies;
       add_book(a,headNode);
   }
    return 0;
}



//adds a book to the ones available to the library
//returns 0 if the book could be added, or an error code otherwise
int add_book(Book book,struct Node* headNode)//add a new book to the system
{
	struct Node* newNode = createNode(book);//create a new node and apply memory
	newNode->next = headNode->next;
	headNode->next = newNode;//update the headnode
	return 0;
}

void printList(struct Node* headNode)//print the book list
{
	struct Node* pMove = headNode->next;//Start iterating from the next one in the head node
	printf("ID\ttitle\tauthor\tyear\tcopies\n");//print header
	while(pMove != NULL)//start iterating
	{
		printf("%d\t%s\t%s\t%d\t%d\n", pMove->book.id, pMove->book.title, pMove->book.authors,pMove->book.year,pMove->book.copies);//Print the current node
		pMove = pMove->next;//move to the next node
	}
}
Book find_book_by_id (const int id,struct Node* headNode)//find book by book id
{
    struct Node* posNode = headNode->next;//Start iterating from the next one in the head node
    while(posNode!=NULL)//start iterating
    {
        if(posNode->book.id==id)//if target book found
        {
            return posNode->book;//return target book
        }
        posNode=posNode->next;//move to the next node
    }



}
int find_book_by_id_bool (const int id,struct Node* headNode)//find book by book id
{
    struct Node* posNode = headNode->next;//Start iterating from the next one in the head node
    while(posNode!=NULL)//start iterating
    {
        if(posNode->book.id==id)//if target book found
        {
            return 1;//return target book
        }
        posNode=posNode->next;//move to the next node
    }
    return 0;


}
//removes a book from the library
//returns 0 if the book could be successfully removed, or an error code otherwise.
int remove_book(Book book,struct Node* headNode)
{
	unsigned int id=book.id;//declare book id
	struct Node* posLeftNode = headNode;
	struct Node* posNode = headNode->next;
	while (posNode != NULL && posNode->book.id!=id)
	{
		posLeftNode = posNode;
		posNode = posLeftNode->next;
	}
	if (posNode == NULL)
	{
		return 0;
	}
	else
	{
		posLeftNode->next = posNode->next;
		free(posNode);
		posNode = NULL;
	}
	return 0;
}

//finds books with a given title.
//returns a BookList structure, where the field "list" is a list of books, or null if no book with the 
//provided title can be found. The length of the list is also recorded in the returned structure, with 0 in case
//list is the NULL pointer.
BookList find_book_by_title (const char *title,struct Node* headNode)//find books by title
{
	BookList booklist; //declare booklist
	booklist.length=0;//Initialize the length of booklist
	struct Node* posNode = headNode->next;//one node to record the booklist
	struct Node* posNode1 = headNode->next;// one node to iterate the list
	while (posNode != NULL )
	{
		if( strcmp(posNode->book.title,title)==0)
		{
			booklist.length++;
		}
		posNode = posNode->next;
	}
	if(!booklist.length)
	{
		printf("no book found!\n");
		return ;
	}
	printf("ID\ttitle\tauthor\tyear\tcopies\n");
	while (posNode1 != NULL )
	{
		if( strcmp(posNode1->book.title, title)==0)
		{
			printf("%d\t%s\t%s\t%d\t%d\n", posNode1->book.id, posNode1->book.title, posNode1->book.authors,posNode1->book.year,posNode1->book.copies);
		}
		posNode1 = posNode1->next;
	}
	return booklist;
}

//finds books with the given authors.
//returns a Booklist structure, where the field "list" is a newly allocated list of books, or null if no book with the 
//provided title can be found. The length of the list is also recorded in the returned structure, with 0 in case
//list is the NULL pointer.
BookList find_book_by_author (const char *author,struct Node* headNode)
{
	BookList booklist; 
	booklist.length=0;
	struct Node* posNode = headNode->next;
	struct Node* posNode1 = headNode->next;
	while (posNode != NULL)
	{
		if( strcmp(posNode->book.authors,author))
		{
			booklist.length++;
		}
		posNode = posNode->next;
	}
	if(!booklist.length)
	{
		printf("no book found!\n");
		return ;
	}
	printf("ID\ttitle\tauthor\tyear\tcopies\n");
	while (posNode1 != NULL )
	{
		if(strcmp(posNode1->book.authors, author)==0)
		{
			printf("%d\t%s\t%s\t%d\t%d\n", posNode1->book.id, posNode1->book.title, posNode1->book.authors,posNode1->book.year,posNode1->book.copies);
		}
		posNode1 = posNode1->next;
	}
	return booklist;
}


//finds books published in the given year.
//returns a Booklist structure, where the field "list" is a list of books, or null if no book with the 
//provided title can be found. The length of the list is also recorded in the returned structure, with 0 in case
//list is the NULL pointer.
BookList find_book_by_year (unsigned int year,struct Node* headNode)
{
	BookList booklist;
	booklist.length=0;
	struct Node* posNode = headNode->next;
	struct Node* posNode1 = headNode->next;
	while (posNode != NULL )
	{
		if( posNode->book.year==year)
		{
			booklist.length++;
		}
		posNode = posNode->next;
	}
	if(!booklist.length)
	{
		printf("no book found!\n");
		return ;
	}
	printf("ID\ttitle\tauthor\tyear\tcopies\n");
	while (posNode1 != NULL )
	{
		if( posNode1->book.year==year)
		{
			printf("%d\t%s\t%s\t%d\t%d\n", posNode1->book.id, posNode1->book.title, posNode1->book.authors,posNode1->book.year,posNode1->book.copies);
		}
		posNode1 = posNode1->next;
	}
	return booklist;
}

